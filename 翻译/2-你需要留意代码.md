>你还是称之为洗稿吧，别称之为翻译，因为有很强的个人色彩，哈哈哈哈

​		夏洛克 · 福尔摩斯会不假思索地得出这样的结论，好的程序员能够写出好的代码。不好的程序员，不能。她们生产出我们必须要清理的怪异内容。你想要书写真正有用的东西，对吗？你想要成为一个优秀的程序员。

好的代码不会凭空产生，它也不是在行星连成线后发生的幸运的反应。想要拥有好的代码，你必须在代码上下足功夫。下足努力。并且只有你只有真心在意好的代码，你才会拥有好的代码。

好的代码不仅仅来自于技术能力。我看见过天分很高的程序员可以生产出，巨大的，令人印象深刻的算法，这些人把语言的标准可在刻心里，但是写着最糟糕的代码。无论是读起来，用起来，还是修改的时候都是及其痛苦的。我看过更多的谦虚的开发者们热衷于写一些非常简单的代码，但是也能写出优雅，易懂，让人乐于接受的代码。

基于我多年的软件开发经验，我的总结是：真正拉开普通和伟大的程序员的差距是：态度（注：我个人对态度的看法是，只和自己的兴趣有关，强迫最多只能使一个人拥有最底线态度，只能影响下线）。好的程序员依托于拥有一个专业的途径，并且想去尽可能写最好的软件，哪怕有着软件工厂的约束和压力。

如地狱般的代码是由善意铺成的。去成为一个有天分的程序员，你必须要拥有更好的动机，并且真正在意这些代码——培养积极的愿景并且发展健康的态度。好的代码是工匠大师细心雕琢的，不是想糊弄的程序员无脑地乱砍，也不是建立一个自认为神秘的代码权威。

你想要书写好代码，你想要成为一个优秀的程序员，所以你在意代码：

- 在任何写代码的情况下，你需要拒绝去破解那些只为了工作的东西，你努力去构造

* In any coding situation, you refuse to hack something that only seems to work. You strive to craft elegant（优雅） code that is clearly correct  (and has good tests to show that it is correct).
* You write code that is *discoverable* (that other programmers can easily pick up and understand), that is *maintainable* (that you, or other programmers, will be easily able to modify in the  future), and that is correct (you take all steps possible to determine  that you have solved the problem, not just made it look like the program works).
* You work well alongside other programmers. No programmer is an  island. Few programmers work alone; most work in a team of programmers,  either in a company environment or on an open source project. You  consider other programmers, and construct code that others can read. You want the team to write the best software possible, rather than to make  yourself look clever.
* Any time you touch a piece of code you strive to leave it better  than you found it (either better structured, better tested, more  understandable...).
* You care about code and about programming, so you are constantly  learning new languages, idioms, and techniques. But you only apply them  when appropriate.
* Fortunately, you're reading this collection of advice because you do  care about code. It interests you. It's your passion. Have fun  programming. Enjoy cutting code to solve tricky problems. Produce  software that makes you proud.

